using System.Net;
using System.Text.Json;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using RinhaBackend2025.Models;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Health Check
builder.Services.AddHealthChecks();

// HTTP Clients for Payment Processors with resilience
builder.Services.AddHttpClient("DefaultProcessor", client =>
{
    client.BaseAddress = new Uri(builder.Configuration["PaymentProcessor:DefaultUrl"] ?? "http://payment-processor-default:8080");
    client.Timeout = TimeSpan.FromMilliseconds(int.Parse(builder.Configuration["PaymentProcessor:TimeoutMs"] ?? "5000"));
});

builder.Services.AddHttpClient("FallbackProcessor", client =>
{
    client.BaseAddress = new Uri(builder.Configuration["PaymentProcessor:FallbackUrl"] ?? "http://payment-processor-fallback:8080");
    client.Timeout = TimeSpan.FromMilliseconds(int.Parse(builder.Configuration["PaymentProcessor:TimeoutMs"] ?? "5000"));
});

var app = builder.Build();

// Configure middleware
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Health Check
app.MapHealthChecks("/health", new Microsoft.AspNetCore.Diagnostics.HealthChecks.HealthCheckOptions
{
    ResponseWriter = async (context, report) =>
    {
        context.Response.ContentType = "application/json";
        var result = JsonSerializer.Serialize(new
        {
            status = report.Status.ToString(),
            processors = new
            {
                default_available = await CheckProcessorConnection("DefaultProcessor"),
                fallback_available = await CheckProcessorConnection("FallbackProcessor")
            },
            timestamp = DateTime.UtcNow
        });
        await context.Response.WriteAsync(result);
    }
});

// Payment endpoint
app.MapPost("/payments", async (
    [FromBody] PaymentRequest request,
    IHttpClientFactory clientFactory,
    ILogger<Program> logger) =>
{
    logger.LogInformation("RECEBIDO: Pagamento {CorrelationId} de {Amount}", request.CorrelationId, request.Amount);

    // Validate request
    if (string.IsNullOrEmpty(request.CorrelationId) || request.Amount <= 0)
    {
        logger.LogWarning("Pagamento inválido: {CorrelationId}, {Amount}", request.CorrelationId, request.Amount);
        return Results.BadRequest(new { error = "Requisição inválida" });
    }

    // Try Default Processor
    try
    {
        var defaultClient = clientFactory.CreateClient("DefaultProcessor");
        var response = await ProcessPaymentLocally(request);
        logger.LogInformation("Pagamento processado com sucesso pelo processador padrão: {CorrelationId}", request.CorrelationId);
        return Results.Ok(response);
    }
    catch (Exception ex)
    {
        logger.LogWarning("Erro no processador padrão: {Message}", ex.Message);
        
        // Try Fallback Processor
        try
        {
            var fallbackClient = clientFactory.CreateClient("FallbackProcessor");
            var response = await ProcessPaymentLocally(request);
            logger.LogInformation("Pagamento processado com sucesso pelo processador fallback: {CorrelationId}", request.CorrelationId);
            return Results.Ok(response);
        }
        catch (Exception fallbackEx)
        {
            logger.LogError("Erro no processador fallback: {Message}", fallbackEx.Message);
            
            // Local processing as last resort
            try {
                var response = await ProcessPaymentLocally(request);
                logger.LogInformation("Pagamento processado localmente com sucesso: {CorrelationId}", request.CorrelationId);
                return Results.Ok(response);
            }
            catch (Exception localEx) {
                logger.LogCritical("Falha no processamento local: {Message}", localEx.Message);
                return Results.StatusCode(500);
            }
        }
    }
});

// Local payment processing function (fallback when external processors are unavailable)
async Task<PaymentResponse> ProcessPaymentLocally(PaymentRequest request)
{
    // Simulate processing delay
    await Task.Delay(100);
    
    // In a real scenario, you'd save to database here
    
    return new PaymentResponse(
        request.CorrelationId,
        request.Amount,
        "approved",
        DateTime.UtcNow,
        "local-fallback"
    );
}

    // Validate request
    if (string.IsNullOrEmpty(request.CorrelationId) || request.Amount <= 0)
    {
        logger.LogWarning("Pagamento inválido: {CorrelationId}, {Amount}", request.CorrelationId, request.Amount);
        return Results.BadRequest(new { error = "Requisição inválida" });
    }

    // Try Default Processor
    try
    {
        var defaultClient = clientFactory.CreateClient("DefaultProcessor");
        var response = await ProcessPaymentLocally(request);
        logger.LogInformation("Pagamento processado com sucesso pelo processador padrão: {CorrelationId}", request.CorrelationId);
        return Results.Ok(response);
    }
    catch (Exception ex)
    {
        logger.LogWarning("Erro no processador padrão: {Message}", ex.Message);
        
        // Try Fallback Processor
        try
        {
            var fallbackClient = clientFactory.CreateClient("FallbackProcessor");
            var response = await ProcessPaymentLocally(request);
            logger.LogInformation("Pagamento processado com sucesso pelo processador fallback: {CorrelationId}", request.CorrelationId);
            return Results.Ok(response);
        }
        catch (Exception fallbackEx)
        {
            logger.LogError("Erro no processador fallback: {Message}", fallbackEx.Message);
            
            // Local processing as last resort
            try {
                var response = await ProcessPaymentLocally(request);
                logger.LogInformation("Pagamento processado localmente com sucesso: {CorrelationId}", request.CorrelationId);
                return Results.Ok(response);
            }
            catch (Exception localEx) {
                logger.LogCritical("Falha no processamento local: {Message}", localEx.Message);
                return Results.StatusCode(500);
            }
        }
    }
});

// Function to check processor connection
async Task<bool> CheckProcessorConnection(string clientName)
{
    try
    {
        var client = app.Services.GetRequiredService<IHttpClientFactory>().CreateClient(clientName);
        var response = await client.GetAsync("/health");
        return response.IsSuccessStatusCode;
    }
    catch
    {
        return false;
    }
}

// Local payment processing function (fallback when external processors are unavailable)
async Task<PaymentResponse> ProcessPaymentLocally(PaymentRequest request)
{
    // Simulate processing delay
    await Task.Delay(100);
    
    // In a real scenario, you'd save to database here
    
    return new PaymentResponse
    {
        CorrelationId = request.CorrelationId,
        Amount = request.Amount,
        Status = "approved",
        ProcessedAt = DateTime.UtcNow,
        ProcessorId = "local-fallback"
    };
}

Console.WriteLine($"[{DateTime.Now:MM/dd/yyyy HH:mm:ss}] Starting Rinha Backend 2025 API...");
app.Run();
