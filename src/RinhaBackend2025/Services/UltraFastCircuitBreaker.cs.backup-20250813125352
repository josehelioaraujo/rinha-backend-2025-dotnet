using System.Runtime.CompilerServices;

namespace RinhaBackend2025.Services;

public interface ICircuitBreaker
{
    bool CanExecute();
    void RecordSuccess();
    void RecordFailure();
}

public sealed class UltraFastCircuitBreaker : ICircuitBreaker
{
    private volatile int _failureCount;
    private volatile DateTime _lastFailureTime;
    private volatile CircuitState _state = CircuitState.Closed;
    private readonly int _failureThreshold;
    private readonly TimeSpan _timeout;

    public UltraFastCircuitBreaker(int failureThreshold = 5, TimeSpan? timeout = null)
    {
        _failureThreshold = failureThreshold;
        _timeout = timeout ?? TimeSpan.FromSeconds(10);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool CanExecute()
    {
        if (_state == CircuitState.Closed) return true;
        
        if (_state == CircuitState.Open)
        {
            if (DateTime.UtcNow - _lastFailureTime > _timeout)
            {
                _state = CircuitState.HalfOpen;
                return true;
            }
            return false;
        }
        
        return true; // HalfOpen
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RecordSuccess()
    {
        _failureCount = 0;
        _state = CircuitState.Closed;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RecordFailure()
    {
        _failureCount++;
        _lastFailureTime = DateTime.UtcNow;
        
        if (_failureCount >= _failureThreshold)
        {
            _state = CircuitState.Open;
        }
    }
}

public enum CircuitState
{
    Closed,
    Open,
    HalfOpen
}
