using RinhaBackend2025.Models;
using Microsoft.Data.Sqlite;

namespace RinhaBackend2025.Services;

public sealed class PaymentWorker : BackgroundService
{
    private readonly IPaymentQueue _queue;
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly ICircuitBreaker _defaultCircuitBreaker;
    private readonly ICircuitBreaker _fallbackCircuitBreaker;
    private readonly string _connectionString;
    private readonly int _workerId;

    public PaymentWorker(
        IPaymentQueue queue,
        IHttpClientFactory httpClientFactory,
        ICircuitBreaker defaultCircuitBreaker,
        ICircuitBreaker fallbackCircuitBreaker,
        IConfiguration configuration,
        int workerId)
    {
        _queue = queue;
        _httpClientFactory = httpClientFactory;
        _defaultCircuitBreaker = defaultCircuitBreaker;
        _fallbackCircuitBreaker = fallbackCircuitBreaker;
        _connectionString = configuration.GetConnectionString("DefaultConnection")!;
        _workerId = workerId;
        
        Console.WriteLine($"PaymentWorker {workerId} iniciado");
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await foreach (var item in _queue.DequeueAsync(stoppingToken))
        {
            try
            {
                await ProcessPaymentAsync(item);
                item.Completion.SetResult(new PaymentResponse { CorrelationId = item.CorrelationId, Amount = item.Amount, Status = "approved", ProcessedAt = DateTime.UtcNow, ProcessorId = "default" });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Worker {_workerId} error: {ex.Message}");
                item.Completion.SetResult(new PaymentResponse { CorrelationId = item.CorrelationId, Amount = item.Amount, Status = "rejected", ProcessedAt = DateTime.UtcNow, ProcessorId = "default" });
            }
        }
    }

    private async Task ProcessPaymentAsync(PaymentQueueItem item)
    {
        bool success = false;
        string processor = "none";

        // Try default processor first
        if (_defaultCircuitBreaker.CanExecute())
        {
            success = await TryProcessorAsync("default", item);
            if (success)
            {
                _defaultCircuitBreaker.RecordSuccess();
                processor = "default";
            }
            else
            {
                _defaultCircuitBreaker.RecordFailure();
            }
        }

        // Try fallback if default failed
        if (!success && _fallbackCircuitBreaker.CanExecute())
        {
            success = await TryProcessorAsync("fallback", item);
            if (success)
            {
                _fallbackCircuitBreaker.RecordSuccess();
                processor = "fallback";
            }
            else
            {
                _fallbackCircuitBreaker.RecordFailure();
            }
        }

        // Always save to database (fail-silent strategy)
        await SavePaymentAsync(item, processor);
    }

    private async Task<bool> TryProcessorAsync(string processorType, PaymentQueueItem item)
    {
        try
        {
            var client = _httpClientFactory.CreateClient(processorType);
            var payload = new
            {
                correlationId = item.CorrelationId,
                amount = item.Amount,
                requestedAt = item.RequestedAt.ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
            };

            var response = await client.PostAsJsonAsync("/payments", payload);
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }

    private async Task SavePaymentAsync(PaymentQueueItem item, string processor)
    {
        using var connection = new SqliteConnection(_connectionString);
        await connection.OpenAsync();

        using var transaction = await connection.BeginTransactionAsync();
        try
        {
            var command = connection.CreateCommand();
            command.CommandText = @"
                INSERT OR REPLACE INTO payments (correlationId, amount, requestedAt, processor, createdAt) 
                VALUES (@id, @amount, @requestedAt, @processor, @createdAt)";

            command.Parameters.AddWithValue("@id", item.CorrelationId);
            command.Parameters.AddWithValue("@amount", item.Amount);
            command.Parameters.AddWithValue("@requestedAt", item.RequestedAt);
            command.Parameters.AddWithValue("@processor", processor);
            command.Parameters.AddWithValue("@createdAt", DateTime.UtcNow);

            await command.ExecuteNonQueryAsync();
            await transaction.CommitAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}
